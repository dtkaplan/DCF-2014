---
output:
  html_document:
    css: ../../CSS/DCF-style.css
    fig_caption: yes
    toc: yes
---

```{r child="../../CSS/DCF-common.Rmd"}
```

```{r include=FALSE}
require(xtable)
```

Many questions take forms such as these:

* "Find the largest ..."
* "Find the three largest ..."
* "Find the smallest within each group ..."

The functions `min()` and `max()` are obvious candidates for carrying out such tasks, but they don't do quite the right thing.  For instance
```{r}
BabyNames %>% 
  summarise( biggest=max( count ) )
```
quickly reveals that the most popular name was given `r BabyNames %>% summarise(biggest=max(count))` times.  But the result doesn't indicate what that popular name was or in what year it was given.

What's needed here is a data verb that will return the one biggest case.  The job of choosing cases that meet a criterion belongs to `filter()`.
```{r}
BabyNames %>% 
  filter( count==max( count ) )
```
Note the difference in the use of `filter()` instead of `summarise()`: rather than creating a new variable as `summarise()` (it's name `biggest` in the example), `filter()` needs a criterion or test.  The criterion `count==max( count )` (with the double equals sign `==`) ask for the case where the value of `count`  matches the largest value of `count`.  That will be the biggest case.

It's also possible to ask for the cases that are almost as popular as the biggest, e.g. at least 90% as popular.
```{r}
BabyNames %>% 
  filter( count > 0.90*max( count ))
```

Frequently, however, the question will be framed in terms of the $n$ biggest or smallest values, not as a fraction of the largest.  To perform such tasks, a new transformation verb is helpful: `rank()`.

`Rank()` does something very simple: it replaces each number in a set with where that number stands with respect to the others.  For instance, the rank of the number 5 in the set 2,5,4,7,2,9,9,8 is 4 because 5 is the 4th smallest number in the set. (The three numbers 2, 2, 4 are smaller than 5.)

Note that `rank()` is not a data verb.  Data verbs take a data table as input and return a data table.  In contrast, `rank()` takes a variable as input and returns a set of the same size that tells where each number in the set stands.  The smallest number in a set of $n$ numbers will have rank 1; the largest will have rank $n$.^[Unless there are ties for the smallest or the largest.]  Since `rank()` transforms a variable into a variable, it's particularly suitable for use in `mutate()` and `filter()`.

To illustrate, here are the 10 most popular names in the `BabyNames` data table.  (Note: `desc()` is used so that `rank()` will work in *descending* order, rather than from smallest to biggest.)
```{r}
BabyNames %>%
  filter( rank( desc(count) ) <= 10 )
```

Of course, `rank()` can be used with other data verbs, such as `group_by()`.
```{r}
BabyNames %>%
  group_by( sex ) %>%
  filter( rank( desc(count) ) <= 10 )
```

You can also perform other tasks, for instance finding the most popular names over all time by adding up the counts over the years:
```{r}
BabyNames %>%
  group_by( sex, name ) %>% 
  summarise( count=sum(count) ) %>%
  filter( rank( desc(count) ) <= 10 ) %>% 
  arrange( desc(count) )
```

### Ties

Often, there are ties.  The `rank()` function deals with these by assigning all the tied values the same rank, which is the mean of the ranks those values would have had if they were not quite tied.

Some rank-like functions are useful if ties are an issue.  For instance, `row_number()` breaks ties in favor of the first case encountered.

### Examples

#### Find the 3rd most popular name in each year

```{r}
PopularByYear <- BabyNames %>% 
  group_by( year ) %>% 
  filter( rank( desc(count) ) == 3) 
head( PopularByYear, 10 )
tail( PopularByYear, 10 )
```

#### Find the top 3 most popular names in each year

This is almost identical to the above, but with `==` replaced by `<=`.

```{r}
Top3ByYear <- BabyNames %>% 
  group_by( year ) %>% 
  filter( rank( desc(count) ) <= 3) %>%  
  arrange( year )
head( Top3ByYear, 15 )
tail( Top3ByYear, 15 )
```

If there is a tie, there's no guarantee that any of the names will be in 3rd place: they might tie for 4th place.  Using `row_number()` instead of rank would help here.

### Arrange within group_by()

Or maybe it should be one of the rank functions in filter.

Within each precinct, which ward had the largest number of votes?  (Hint: Make a data table with the number of votes in each `Precinct` `Ward` combination.  Arrange this by `Precinct` and the number of votes.)


