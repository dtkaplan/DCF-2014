---
output:
  html_document:
    css: ~/KaplanFiles/DCF-2014/CSS/DCF-style.css
    fig_caption: yes
    toc: yes
---

```{r child="/Users/kaplan/KaplanFiles/DCF-2014/CSS/DCF-common.Rmd"}
```

```{r include=FALSE}
data( BabyNames )
data( Minneapolis2013 )
data( CountryData )
```

```{r include=FALSE}
opts_chunk$set( cache=TRUE )
```

You have already seen two data verbs:

* `summarise()`
* `group_by()`

Although these are being written in computer notation, it's also perfectly legitimate to express actions using them as English verbs.  For instance: "Group the baby names by sex and year.  Then summarize the groups by adding up the total number of births for each group. This will be the result."  That's English. Here's the equivalent statement in computer notation:

```{r results='hide'}
Result <- 
  BabyNames %>% 
  group_by( sex, year ) %>%
  summarise( total=sum( count ) )
```

```{r echo=FALSE,results='asis'}
Result %>% sample_n( size=6 ) %>% arrange( year ) %>% xtable()
```

These notes will introduce you to five more data verbs:

* `select()`
* `mutate()`
* `filter()`
* `arrange()`
* `join()`

As with `group_by()` and `summarise()`, each is a standard English word whose action on data is reflected in the colloquial, everyday meaning.  And, like English, intricate and detailed statements can be made by combining the words into expressions.

## Select

Selecting from a data table means choosing one or more variables from the table.  Reasons to do this:

* Simplify the table you are working on.
* Rename one or more of the variables to make it more convenient to work with.

The syntax is similar to that of `group_by()` or `summarise()`.  A data table is provided as input along with the names of the variables you are selecting.  The result produced is a new data table with just those variables.

To illustrate, here's the first few cases in the `BabyNames` data table:

```{r echo=FALSE,results='asis'}
BabyNames %>% head( ) %>% xtable( )
```

And here is the result of selecting just the `name` and `year` variables:

```{r results='hide', ref.label='select2'}
BabyNames %>% select( name, year )
```

```{r echo=FALSE,results='asis'}
BabyNames %>% select( name, year ) %>% head() %>% xtable()
```

If you want to rename a variable, use a named argument, as with `when=year` in the following:

```{r results='hide', ref.label='select3'}
BabyNames %>% select( name, when=year )
```

```{r echo=FALSE,results='asis'}
BabyNames %>% select( name, when=year ) %>% 
  head() %>% xtable()
```

## Filter

To "filter" means to remove unwanted material.  The data verb "filter" removes unwanted cases, passing through to the result only those cases that are wanted or needed.  Filtering constrasts with selecting.  Selecting passes the specified *variables*; filtering passes the specified cases.

In selecting, the variables are specified by name, e.g.
```{r results="hide"}
BabyNames %>% select( year, count )
```

With filtering, the cases are specified by one or more criteria or tests.  The tests are generally constructed with variables and functions like `==`, `>`, `<`, `%in%`, and so on.  For instance, here's how you can filter out the boys, producing a result with only the girls' names:
```{r results='asis'}
BabyNames %>% filter( sex=="F") %>%
  sample_n( size=10 ) %>% xtable()
```

Here are the cases for either sex for babies born after 1990:
```{r results="asis"}
BabyNames %>% filter( year > 1990 ) %>% 
  sample_n( size=10 ) %>% xtable()
```

Here are the girls born after 1990:

```{r eval=FALSE}
BabyNames %>% filter( year > 1990, sex=="F")
```

```{r echo=FALSE,results='asis',scroller=300}
BabyNames %>% filter( year > 1990, sex=="F") %>%
  sample_n( size=30 ) %>% xtable()
```

You can specify as many tests as you like.  The `filter()` function will pass through only those cases that pass *all* the tests.

Sometimes you may want to set "either-or" criteria, say the babies who are female *or* born after 1990:
```{r results='hide'}
BabyNames %>% filter( year>1990 | sex=="F") 
```

It's also possible to test for a variable being any of several different variables.  For instance, here are the babies born in any of 1980, 1990, 2000, and 2010:

```{r results='asis'}
BabyNames %>% 
  filter( year %in% c(1980, 1990, 2000, 2010)) %>%
  sample_n( size=12 ) %>% 
  arrange(year) %>%
  xtable()
```



## Mutate

The word "mutate" means to change in form or nature. The data verb "mutate" is a bit more specific: to change a variable or add new variables based on the existing ones.  The data verb always refers to variables; mutation leaves the cases exactly as they were.

Often, mutation is used to combine or transform existing variables into a new variable. For instance, the `CountryData` data table has variables `pop` and `area` giving the population and area (in km^2) of each country.  Suppose you wanted to know the population *density*, that is, how many people per unit area.  Using mutate, you creating a new variable that is population / area.
```{r results='asis'}
Result <-
  CountryData %>%
  mutate( popDensity=pop/area ) %>% 
  na.omit() %>% 
  sample_n(size=10) %>% xtable()
```

The resulting data table, named `Result` here, contains all the original variables as well as the newly created ones.    

`Result` has 77 variables.  Rather than show them all, here are just some relevant variables for a few of the countries.

```{r ref.label="popdensity",results='hide'}
Result %>% select( country, pop, area, popDensity) 
```

```{r echo=FALSE,results='asis'}
Result %>% select( country, pop, area, popDensity) %>% arrange(desc(popDensity)) %>% head() %>% xtable( )
```

## Arrange

Arranging sets the order of cases.  It does not change the variables --- that's a job for `select()`.  Similarly, arranging does not filter the cases.  Arranging merely sets the order of cases according to some criterion that you specify.

For instance, here are the first-choices from the Minneapolis mayoral election in 2013 found by counting the ballots:

```{r results='asis'}
Minneapolis2013 %>%
  group_by( First ) %>% 
  summarise( total=n() ) %>%
  head() %>% xtable()
```

The alphabetical order in the above might be good for some purposes.  If your goal is to show who won and how they did compared to the other candidates, it's better to arrange the results by `total` in descending order.
```{r results='asis'}
Minneapolis2013 %>%
  group_by( First ) %>% 
  summarise( total=n() ) %>%
  arrange( desc(total) ) %>%
  head() %>% xtable()
```
By default, the arrangement goes in ascending order: from lowest to highest.  You can also arrange for the order to be descending, with the highest value first.

## Join

Each of the data verbs described until now takes one *one* data table as an input.  Join is different.  It's well named: it brings together *two* data tables. Once you can join two data tables, you can join any number of data tables by repeated joins.  Joining is at the heart of combining data from multiple sources.

It's conventional to refer to the two tables as the "left" and "right" tables.



```{r echo=FALSE}
set.seed(42)
codes <- sort(round( runif(10,min=10000,max=99999)))
Left <- data.frame( clinicName=LETTERS[1:9],
                    postalCode=codes[c(1,2,3,2,4,5,6,6,7)],
                    y=9:1,x=1)
Right <- data.frame( postalCode=codes[c(2,1,1,9,8,4)], over65=round(runif(6,0,100))/100,y2=9:4,x2=2)
Connections <- inner_join( Left, Right ) 
JustMatches <- semi_join( Left, Right )
LL <- select( Left, clinicName, postalCode )
RR <- select( Right, postalCode, over65 )
```

To illustrate the differences and similarities between the different kinds of join, suppose you have these two tables:

* Left: cases are procedures performed at medical clinics. The variables: `clinicName`, `postalCode`.  Each clinic does multiple procedures. 


```{r echo=FALSE,results='asis'}
xtable( select(Left, clinicName, postalCode ))
```

* Right: cases are postal codes. Variables reflect the demographics of that postal code: `postalCode`, `over65`, etc.

```{r echo=FALSE,results='asis'}
xtable( select( Right, postalCode, over65))
```

Variables that appear in both the left and right tables are called "overlap variables."  The only overlap variable here is `postalCode`.

The overlap variables determine which cases will go into the output table.  In this example, there is just one overlap variable: `postalCode`.   

The diagram below shows the cases in the left and right tables.  The lines show the matches between left and right. The cases connected by a match are the overlap cases; there are five of them in the diagram.  Cases without a match also appear in both the left and right tables.

```{r echo=FALSE}
ggplot() + geom_text(data=Left, 
                      aes(x=x,y=y,label=postalCode)) +
           geom_text(data=Left, 
                      aes(x=x-1,y=y,label=clinicName)) +
           geom_text(data=Right, 
                      aes(x=x2,y=y2,label=postalCode)) +
           geom_text(data=Right, 
                      aes(x=x2+1,y=y2,label=over65)) + 
           geom_segment(data=Connections, size=3, alpha=.5, 
               aes(x=x+.13,y=y,xend=x2-.13,yend=y2)) +
  theme(
    plot.background = element_blank()
   ,panel.grid.major = element_blank()
   ,panel.grid.minor = element_blank()
   ,panel.border = element_blank()
  ) +
  scale_x_continuous(breaks=NULL,limits=c(-.5,3.5)) +
  scale_y_discrete(breaks=NULL) + xlab("") + ylab("")

```


Note that there are three different kinds of cases here:

1. The matching cases that are in both the left and right. These come as pairs: the cases connected by a line in the diagram.
2. Non-matching ones in the left.
3. Non-matching ones in the right.

There are different types of join. The type of join specifies whether you want to include in the output the matching cases, the matching pairs, or the non-matching cases.  

#### Inner Join

An *inner join* gives the matching pairs.  Note that clinic A, which had two matches in the right table, appears twice, once for each matching pair in which clinic A is involved.

```{r eval=FALSE}
merge( LL, RR )
```

```{r echo=FALSE,results='asis'}
xtable( merge( LL, RR ) )
```

#### Outer Join

An *outer join* can include cases where there is no match. You might want to include the unmatched cases from the left table, from the right table, or from both tables. 

##### Unmatched cases from the left table

```{r eval=FALSE}
merge( LL, RR, all.x=TRUE )
```

```{r echo=FALSE,results='asis'}
xtable( merge( LL, RR, all.x=TRUE ) )
```

##### Unmatched cases from the right table

```{r eval=FALSE}
merge( LL, RR, all.y=TRUE )
```

```{r echo=FALSE,results='asis'}
xtable( merge( LL, RR, all.y=TRUE ) )
```


##### Unmatched cases from both tables
Do straight merge on filtered G8 countries and G20 countries

```{r eval=FALSE}
merge( LL, RR, all=TRUE )
```

```{r echo=FALSE,results='asis'}
xtable( merge( LL, RR, all=TRUE ) )
```

### Using Join

Join is useful for many tasks. 

#### Translate 

Translate a value from the left table according to a specification in the right table.  [List of synonyms for countries and an official identifier.  Translate the synonmyms into the official identifier.]
[Marking candidates as "minor" in Minneapolis Mayor]

For example, in the Minneapolis mayoral election, voters made `r length(unique(Minneapolis2013$First))` different first choices.^[There are the 36 candidates as well as no choice ("undervote") or disallowed multiple choices ("overvote").]  It's ungainly to look at the relationships among all those choices.  A sensible approach is to group the minor candidates together.

Defining a minor candidate to be one who got fewer than 1000 votes, it's possible to create a table identifying the minor candidates:

```{r}
Totals <- Minneapolis2013 %>%
  group_by( First ) %>%
  summarise( nVotes=n() )
CandidateGroups <- 
  Totals %>% 
  mutate( Candidate=ifelse( nVotes>1000, 
                            as.character(First), 
                            "Minor") )
```

```{r echo=FALSE,results='asis',scroller=300}
xtable(CandidateGroups)
```
```{r}
nrow(CandidateGroups)
```

This table gives the translation between the listing in `First` and listing that lumps minor candidates together. There is one case for each candidate. Joining the translation table with the vote table produces a new column, with one case for each ballot and the minor candidates marked as such. 

```{r eval=FALSE}
merge( Minneapolis2013, CandidateGroups, all.x=TRUE )
```

```{r echo=FALSE,results='asis',scroller=300}
merge( Minneapolis2013, CandidateGroups, all.x=TRUE) %>% 
  head(500) %>% select( Candidate, First, Second)
  xtable
```




#### Complete 

Often, information is spread among multiple sources.  Joining can bring this information together.

For instance, here are the population and area variables from `CountryData`.

```{r}
PopArea <-
  select( CountryData, country, area, pop)
```
```{r eval=FALSE}
PopArea
```

```{r echo=FALSE,results='asis',scroller=300}
xtable(PopArea)
```

From a different source, here are the locations of the various countries:

```{r eval=FALSE}
CountryCentroids
```

```{r echo=FALSE,results='asis',scroller=300}
xtable(CountryCentroids)
```

A join will bring together these two sources:

```{r}
Together <- merge( PopArea, CountryCentroids )
```
```{r eval=FALSE}
Together
```
```{r echo=FALSE,results='asis',scroller=300}
xtable(Together)
```

#### Filter

You can use the `filter()` function to extract those cases that meet a given criterion.  Sometimes you may have a list of the cases you want.  `merge()` lets you choose the cases you want in that list.

For example, here is a list of the G8 countries.
```{r}
G8 <- 
  CountryGroups %>%
  filter( G8 ) %>%
  select( country )
```

```{r eval=FALSE}
G8
```

```{r echo=FALSE,results='asis'}
xtable(G8)
```

The `G8` table can be used to extract the G8 countries from another table:
```{r}
G8Data <- merge( Together, G8 )
```
```{r eval=FALSE}
G8Data
```

```{r echo=FALSE,results='asis'}
xtable( G8Data )
```



## Some other data verbs

* `sample_n( )` chooses random cases from a data table.  The number of cases to be sampled is set by the named argument, `size=`.  Among other things, `sample_n()` is useful for dra

## Elaboration: Data verb languages

The notation used in these notes is `dplyr`.  Keep in mind that this is just one of several notations.  Some of them are: 

* dplyr - R 
* data.table - R
* SQL - database servers

Here is the same expression in these different notations:

* dplyr
    BabyNames %>% group_by(year,sex) %>% summarise( nNames=n() )
* SQL
    "BabyNames" > GROUP_BY("year", "sex") > SUMMARISE(COUNT() AS "nNames")
* data.table
    BabyNames[, length(count), by=c("sex","year") ]
`dplyr` will generate SQL.
