---
output:
  html_document:
    css: ~/KaplanFiles/DCF-2014/CSS/DCF-style.css
    fig_caption: yes
    toc: yes
---

```{r child="/Users/kaplan/KaplanFiles/DCF-2014/CSS/DCF-common.Rmd"}
```

```{r include=FALSE}
data( BabyNames )
data( Minneapolis2013 )
data( CountryData )
```


You have already seen two data verbs:

* `summarise()`
* `group_by()`

Although these are being written in computer notation, it's also perfectly legitimate to express actions using them as English verbs.  For instance: "Group the baby names by sex and year.  Then summarize the groups by adding up the total number of births for each group. This will be the result."  That's English. Here's the equivalent statement in computer notation:

```{r results='hide'}
Result <- 
  BabyNames %>% 
  group_by( sex, year ) %>%
  summarise( total=sum( count ) )
```

```{r echo=FALSE,results='asis'}
Result %>% sample_n( size=6 ) %>% arrange( year ) %>% xtable()
```

These notes will introduce you to five more data verbs:

* `select()`
* `mutate()`
* `filter()`
* `arrange()`
* `join()`

As with `group_by()` and `summarise()`, each is a standard English word whose action on data is reflected in the colloquial, everyday meaning.  And, like English, intricate and detailed statements can be made by combining the words into expressions.

## Select

Selecting from a data table means choosing one or more variables from the table.  Reasons to do this:

* Simplify the table you are working on.
* Rename one or more of the variables to make it more convenient to work with.

The syntax is similar to that of `group_by()` or `summarise()`.  A data table is provided as input along with the names of the variables you are selecting.  The result produced is a new data table with just those variables.

To illustrate, here's the first few cases in the `BabyNames` data table:

```{r echo=FALSE,results='asis'}
BabyNames %>% head( ) %>% xtable( )
```

And here is the result of selecting just the `name` and `year` variables:

```{r results='hide', ref.label='select2'}
BabyNames %>% select( name, year )
```

```{r echo=FALSE,results='asis'}
BabyNames %>% select( name, year ) %>% head() %>% xtable()
```

If you want to rename a variable, use a named argument, as with `when=year` in the following:

```{r results='hide', ref.label='select3'}
BabyNames %>% select( name, when=year )
```

```{r echo=FALSE,results='asis'}
BabyNames %>% select( name, when=year ) %>% 
  head() %>% xtable()
```

## Filter

To "filter" means to remove unwanted material.  The data verb "filter" removes unwanted cases, passing through to the result only those cases that are wanted or needed.  Filtering constrasts with selecting.  Selecting passes the specified *variables*; filtering passes the specified cases.

In selecting, the variables are specified by name, e.g.
```{r results="hide"}
BabyNames %>% select( year, count )
```

With filtering, the cases are specified by one or more criteria or tests.  The tests are generally constructed with variables and functions like `==`, `>`, `<`, `%in%`, and so on.  For instance, here's how you can filter out the boys, producing a result with only the girls' names:
```{r results='asis'}
BabyNames %>% filter( sex=="F") %>%
  sample_n( size=10 ) %>% xtable()
```

Here are the cases for either sex for babies born after 1990:
```{r results="asis"}
BabyNames %>% filter( year > 1990 ) %>% 
  sample_n( size=10 ) %>% xtable()
```

Here are the girls born after 1990:
```{r results='asis'}
BabyNames %>% filter( year > 1990, sex=="F") %>%
  sample_n( size=10 ) %>% xtable()
```

You can specify as many tests as you like.  The `filter()` function will pass through only those cases that pass *all* the tests.

Sometimes you may want to set "either-or" criteria, say the babies who are female *or* born after 1990:
```{r results='hide'}
BabyNames %>% filter( year>1990 | sex=="F") 
```

It's also possible to test for a variable being any of several different variables.  For instance, here are the babies born in any of 1980, 1990, 2000, and 2010:

```{r results='asis'}
BabyNames %>% 
  filter( year %in% c(1980, 1990, 2000, 2010)) %>%
  sample_n( size=12 ) %>% 
  arrange(year) %>%
  xtable()
```



## Mutate

The word "mutate" means to change in form or nature. The data verb "mutate" is a bit more specific: to change a variable or add new variables based on the existing ones.  The data verb always refers to variables; mutation leaves the cases exactly as they were.

Often, mutation is used to combine or transform existing variables into a new variable. For instance, the `CountryData` data table has variables `pop` and `area` giving the population and area (in km^2) of each country.  Suppose you wanted to know the population *density*, that is, how many people per unit area.  Using mutate, you creating a new variable that is population / area.
```{r results='asis'}
Result <-
  CountryData %>%
  mutate( popDensity=pop/area ) %>% 
  na.omit() %>% 
  sample_n(size=10) %>% xtable()
```

The resulting data table, named `Result` here, contains all the original variables as well as the newly created ones.    

`Result` has 77 variables.  Rather than show them all, here are just some relevant variables for a few of the countries.

```{r ref.label="popdensity",results='hide'}
Result %>% select( country, pop, area, popDensity) 
```

```{r echo=FALSE,results='asis'}
Result %>% select( country, pop, area, popDensity) %>% arrange(desc(popDensity)) %>% head() %>% xtable( )
```

## Arrange

Arranging sets the order of cases.  It does not change the variables --- that's a job for `select()`.  Similarly, arranging does not filter the cases.  Arranging merely sets the order of cases according to some criterion that you specify.

For instance, here are the first-choices from the Minneapolis mayoral election in 2013 found by counting the ballots:

```{r results='asis'}
Minneapolis2013 %>%
  group_by( First ) %>% 
  summarise( total=n() ) %>%
  head() %>% xtable()
```

The alphabetical order in the above might be good for some purposes.  If your goal is to show who won and how they did compared to the other candidates, it's better to arrange the results by `total` in descending order.
```{r results='asis'}
Minneapolis2013 %>%
  group_by( First ) %>% 
  summarise( total=n() ) %>%
  arrange( desc(total) ) %>%
  head() %>% xtable()
```
By default, the arrangement goes in ascending order: from lowest to highest.  You can also arrange for the order to be descending, with the highest value first.

## Join

Each of the data verbs described until now takes one *one* data table as an input.  Join is different.  It's well named: it brings together *two* data tables. Once you can join two data tables, you can join any number of data tables by repeated joins.  Joining is at the heart of combining data from multiple sources.

It's conventional to refer to the two tables as the "left" and "right" tables.

As you'll see, there are several different kinds of join.  These let you accomplish different tasks.  Among these are:

* Complete --- Add information about individual cases from the right table to the information that's already in the left table.  [Which countries are in the G8]
* Identify --- Find those cases in the left table that have a match in the right. [Give back just those countries in the G8]
* Translate --- Translate a value from the left table according to a specification in the right table.  [List of synonyms for countries and an official identifier.  Translate the synonmyms into the official identifier.]


```{r echo=FALSE}
set.seed(42)
codes <- sort(round( runif(10,min=10000,max=99999)))
Left <- data.frame( clinicName=LETTERS[1:9],
                    postalCode=codes[c(1,2,3,2,4,5,6,6,7)],
                    y=9:1,x=1)
Right <- data.frame( postalCode=codes[c(2,1,1,9,8,4)], over65=round(runif(6,0,100))/100,y2=9:4,x2=2)
LL <- select( Left, clinicName, postalCode )
RR <- select( Right, postalCode, over65 )
Connections <- inner_join( LL, RR ) 
JustMatches <- semi_join( LL, RR )
```

To illustrate the differences and similarities between the different kinds of join, suppose you have these two tables:

* Left: cases are procedures performed at medical clinics. The variables: `clinicName`, `postalCode`.  Each clinic does multiple procedures. 


```{r echo=FALSE,results='asis'}
xtable( select(Left, clinicName, postalCode ))
```

* Right: cases are postal codes. Variables reflect the demographics of that postal code: `postalCode`, `over65`, etc.

```{r echo=FALSE,results='asis'}
xtable( select( Right, postalCode, over65))
```

Variables taht appear in both the left and right tables are called "overlap variables."  The only overlap variable here is `postalCode`.

The overlap variables determine which cases will go into the output table.  In this example, there is just one overlap variable: `postalCode`.   

The diagram below shows the cases in the left and right tables.  The lines show the matches between left and right. The cases connected by a match are the overlap cases; there are five of them in the diagram.  Cases without a match also appear in both the left and right tables.

```{r echo=FALSE}
ggplot() + geom_text(data=Left, 
                      aes(x=x,y=y,label=postalCode)) +
  geom_text(data=Left, 
                      aes(x=x-1,y=y,label=clinicName)) +
           geom_text(data=Right, 
                      aes(x=x2,y=y2,label=postalCode)) +
  geom_text(data=Right, 
                      aes(x=x2+1,y=y2,label=over65)) + 
  geom_segment(data=Connections, size=3, alpha=.5, 
               aes(x=x+.13,y=y,xend=x2-.13,yend=y2))+
  theme(
    plot.background = element_blank()
   ,panel.grid.major = element_blank()
   ,panel.grid.minor = element_blank()
   ,panel.border = element_blank()
  ) +
  scale_x_continuous(breaks=NULL,limits=c(-.5,3.5)) +
  scale_y_discrete(breaks=NULL) + xlab("") + ylab("")

```


Note that there are three different kinds of cases here:

1. The matching cases that are in both the left and right. These come as pairs: the cases connected by a line in the diagram.
2. Non-matching ones in the left.
3. Non-matching ones in the right.

There are different types of join. The type of join specifies whether you want to include in the output the matching cases, the matching pairs, or the non-matching cases.  

#### Inner Join

An *inner join* gives the matching pairs.  Note that clinic A, which had two matches in the right table, appears twice, once for each matching pair in which clinic A is involved.

```{r echo=FALSE,results='asis'}
xtable( inner_join( LL, RR ) )
```

Inner joins are useful for adding information from another source about the cases in the left table.  As an example, consider the following table (which is a small part of the `CountryData` table).

```{r echo=FALSE}
CountryLeft <- CountryData[c( 48, 70, 89, 109, 110, 174, 183, 221, 242, 248), 1:3]
row.names(CountryLeft) <- NULL
```

```{r echo=FALSE,results='asis'}
xtable( CountryLeft )
```

There are many international groups to which countries may belong.  Some famous ones are the G8 and G20 industrialized economies.  Here's part of the `CountryGroups` table that identifies the membership for three different international groups.

```{r echo=FALSE,results='asis'}
set.seed(129)
CountryGroups %>% sample_n(size=8) %>% xtable()
```

```{r}
merge(CountryLeft, CountryGroups)
merge(CountryLeft, CountryGroups, all.x=TRUE)
```

Do straight merge

Do straight merge on filtered G8 countries and G20 countries

#### Left Join

Merge with all.x=TRUE.

A *left join* includes the results of the inner join along with all the non-matching cases from the left table.  For the non-matching cases, the value of the variable from the right table is "missing" data.

```{r echo=FALSE,results='asis'}
xtable( left_join( LL, RR ) )
```

An left join can attach the information from the `CountryGroups` table to the geographic/demographic data. 

```{r echo=FALSE, results='hide'}
left_join( CountryLeft, CountryGroups )
```


#### Semi Join

A *semi join* gives each case in the left table that has a match in the right, but doesn't duplicate cases that appear in more than one matching pair.

```{r echo=FALSE,results='asis'}
xtable( semi_join( LL, RR ))
```

Three uses for join.



The join is done on a case-by-case basis.  Every case in the left table is compared to every case in the right table.  If there is a match between a left case and a right case --- in this example, if the postal codes are identical --- there will be a resulting case in the output with values for each of the variables drawn from 



Join works on a case-by-case basis.  That is, each and every case in one table is connected to each and every case in the other table.  


Join: minor candidates

Join: 

* select out the G20 countries
* add a variable indicating whether a country is in the G20 --- make a map


Mutate, Filter & Select, Arrange?  save Join for later.

Example with Mutate: Calculation the proportion of smokers who are alive adjusted for sex and age.  You'll need `mutate()` to add the proportion variable on.



## Some other data verbs

* `sample_n( )` chooses random cases from a data table.  The number of cases to be sampled is set by the named argument, `size=`.  Among other things, `sample_n()` is useful for dra

## Elaboration: Data verb languages

The used in these notes is `dplyr`.  A complete list of others would be long, 
* dplyr - R 
* data.table - R
* SQL - database servers

`dplyr` will generate SQL.
