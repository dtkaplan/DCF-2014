---
title: "Scraping Zip Codes"
author: "Mengdie Wang"
date: "May 29, 2014"
output: html_document
---

```{r include=FALSE}
require(XML)
require(stringr)
```

## The Problem

Create a database of zip codes by scraping the data at <www.brainyzip.com>
```{r}
zipstem <- "http://www.brainyzip.com/zipcodes/"
```
After the stem comes the first two digits, followed by the whole 5-digit zip code.  e.g. `zipcodes/10/10021`.  There is also demographic and economic data at URL's like `demographic/10/demographic_10021`.

Given a zip code, e.g., `'55106'`

Remember, some zip codes start with zero.  Here's a program to add the leading zeros.
```{r}
fixZipZeros <- function(zipChar) {
  ndigits <- nchar(zipChar)
  zips <- ifelse( ndigits==5, 
                  zipChar,
                  ifelse( ndigits==4, 
                          paste('0',zipChar,sep=''),
                          paste('00',zipChar,sep=''))
                  )
  return(zips)
  }
```

Turn the 5 character zip code into a brainyzip URL:
```{r}
makeZipURL <- function(zipChar) {
  URLs <- paste( "http://www.brainyzip.com/zipcodes/",
                 substr(zipChar,1,2),
                 "/",zipChar,".html", sep="")
  return(URLs)
}
```
 
Helper function.  Turn a two column dataframe into a list.
```{r} 
twoCol2List <- function(df){
  L <- as.list(as.character(df[[2]]))
  names(L) <- df[[1]]
  return(L)
  }
```

```
Test cases:
```{r}
fixZipZeros('532')
fixZipZeros('4321')
fixZipZeros('55106')
testURL <- makeZipURL(fixZipZeros('10001'))
```

Read data from the site.  Get a list of tables from the site.
```{r}
info <- readHTMLTable(testURL,stringsAsFactors=FALSE)
```

Tables of interest are 3 and 5:
```{r}
three <- twoCol2List(info[[3]])
five <- twoCol2List(info[[5]])
both <- c(three, five)
```

After conversion to a data frame, some of the zip codes have variables with blank names, others don't.  So kill the blanks, which have names like `X..1`.

```{r}
killBlanks <- function(zipList) {
  inds <- grep('^X\\.',names(zipList))
  return(zipList[-inds])
}
```


```{r}
readOneZip <- function(zip){
  if (!is.character(zip)) stop("Give me a character string, not a number!")
  URL <- makeZipURL(fixZipZeros(zip))
  info <- try(readHTMLTable(URL, stringsAsFactors=FALSE), silent=TRUE)
  if( class(info)=='try-error' || length(info) < 3 ) return(NULL)
  res <- list(three=NA,five=NA)
  res$three <- twoCol2List(info[[3]])
  if (length(info) >= 5 ) {
    res$five <- twoCol2List(info[[5]])
  }
  # tmp$ZIP <- zip
  return(res)
  }
```

```{r}
convertCommaToNumber <- function(v){
  v <- as.numeric(sub(',','',as.character(v)))
}

# Extract the square kilometers
convertAreaToNumber <- function(v) {
  v <- as.character(v)
  tmp <- stringr::str_match(v, "^[0-9.]+ square miles([0-9.]+) square kilometers$")
  return(as.numeric( tmp[,2]))
}
```

```{r}
readManyZips <- function(zipVector) {
  if (length(zipVector) < 1) stop("Give me some zips!")

  # Use fixed names for both, so that you know the order!
  # Then you can process things, column by column.
  
  zipInfo <- readOneZip(zipVector[1]) 
  nms3 <- names(zipInfo$three)
  res3 <- matrix(NA,nrow=length(zipVector),ncol=length(nms3) )
  colnames(res3) <- nms3
  res3[1,] <- unlist(lapply(zipInfo$three,as.character))
  nms5 <- names(zipInfo$five)
  nms5 <- nms5[nms5!='']
  res5 <- matrix(NA,nrow=length(zipVector),ncol=length(nms5) )
  colnames(res5) <- nms5
  res5[1,] <- unlist(lapply(zipInfo$five[nms5],as.character))
  for (k in 2:length(zipVector)) {
    cat(paste(k,zipVector[k],','))
    zipInfo <- readOneZip(zipVector[k]) 
    if (is.null(zipInfo)) next
    three <- zipInfo$three[nms3]
    # fix any elements that are missing
    three[which(lapply(three,length)==0)] <- " "
    if (!is.null(three)) try(res3[k,] <- unlist(lapply(three, as.character)))
    five <- zipInfo$five[nms5]
    five[which(lapply(five,length)==0)] <- " "
    if( !is.null(five)) try(res5[k,] <- unlist(lapply(five[nms5], as.character)))
    }

  return(list(A=res3,B=res5))
  }
```
garbage <- function(hoo){
  res3 <- do.call(data.frame, as.list(rep(NA,length(nms)))) # set up empty data frame
  
  res3 <- killBlanks(data.frame(zipInfo$three ))
  # res5 <- killBlanks(data.frame(zipInfo$five)) 
  for (k in 2:length(zipVector) ) {
    zipInfo <- killBlanks(data.frame(readOneZip( zipVector[k] )))
    res3 <- cbind(res3, killBlanks(data.frame(zipInfo$three)))
   }
  # Fix up columns --- just identifying them here
  factorToCharacter <- c(61,6)
  factorToNumber    <- c(2)
  areaToNumber <- c(4,5)
  commaToNumber <- c(15,16,17,20)
  
  return(res3)
  }
```


Test on several zip codes:
```{r}
set.seed(4)
n <- 500
myzips <- read.csv("/Users/kaplan/KaplanFiles/DCF-2014/CaseStudies/ZipCodes/zip_codes_states.csv")
z <- sample(myzips$zip_code, size=n, replace=FALSE )
tmp <- readManyZips( as.character(z))
```

Fix the class of the columns
```{r}
fixZIPS <- function(tmp,zips=myzips$zip_code) {
  A <- data.frame(tmp$A)
  A$ZIP <- as.character(zips)
  A$State.Zip.Codes. <- NULL
  for (column in c(2,3,9,11,12)) {
    A[[column]] <- convertCommaToNumber(A[[column]])
  }
  for (column in c(4,5)) {
    A[[column]] <- convertAreaToNumber(A[[column]])
  }
  B <- data.frame(tmp$B)
  B$ZIP <- as.character(zips)
  for (column in c(1:40,42:46) ) {
    B[[column]] <- convertCommaToNumber(B[[column]])
  }
  B <- B[,-c(24,33,41)] 
  return(list(zipGeography = A, zipDemographics = B ) )
}
```

Read them in bunches:

```{r}
readInBunches <- function(bunchSize) {
  myzips <- read.csv("/Users/kaplan/KaplanFiles/DCF-2014/CaseStudies/ZipCodes/zip_codes_states.csv")
  # Get the basic structure
  zipInfo <- readOneZip('10001') 
  nms3 <- names(zipInfo$three)
  nms5 <- names(zipInfo$five)
  nms5 <- nms5[nms5!='']

  
#  res5[1,] <- unlist(lapply(zipInfo$five[nms5],as.character))
  
  starts <- seq(1,nrow(myzips),by=bunchSize)
  for (bunch in 1:length(starts)) {
    inds <- seq(starts[bunch],starts[bunch]+bunchSize-1)
    inds <- inds[inds<=nrow(myzips)]
    zipVector <- as.character(myzips$zip_code[inds])
    # pre-allocate the matrix storage
    res3 <- matrix(NA,nrow=length(zipVector),ncol=length(nms3) )
    colnames(res3) <- nms3
    res5 <- matrix(NA,nrow=length(zipVector),ncol=length(nms5) )
    cat(paste("\nBunch",bunch,"of",length(starts), ":\n"))
    colnames(res5) <- nms5
    for (k in 1:length(zipVector)) {
     cat(paste(k,zipVector[k],','))
     zipInfo <- readOneZip(zipVector[k]) 
     if (is.null(zipInfo)) next
     three <- zipInfo$three[nms3]
     # fix any elements that are missing
     three[which(lapply(three,length)==0)] <- " "
     if (!is.null(three)) try(res3[k,] <- unlist(lapply(three, as.character)))
     five <- zipInfo$five[nms5]
     five[which(lapply(five,length)==0)] <- " "
     if( !is.null(five)) try(res5[k,] <- unlist(lapply(five[nms5], as.character)))
    }

    tmp <- list(A=res3,B=res5)
    
    # convert columns and save files
    
    tmp <- fixZIPS(tmp,as.character(z[inds]))
    zipGeography <- tmp$zipGeography
    zipDemographics <- tmp$zipDemographics
    save(zipGeography,file=paste('geo-',bunch,'.rda',sep=''))
    save(zipDemographics,file=paste('demo-',bunch,'.rda',sep=''))
  }  
}
```

